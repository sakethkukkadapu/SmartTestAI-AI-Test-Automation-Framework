"""
AI-generated test for the users endpoint.
Generated by SmartTestAI prompt_generator on 2025-07-24
"""
import os
import pytest
import requests
import json
from jsonschema import validate

# Import necessary modules
import sys
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
from config.config_loader import ConfigLoader
from utils.schema_validator import SchemaValidator

# Load configuration
config = ConfigLoader().load_config()
BASE_URL = config.get("api", {}).get("base_url", "https://api.example.com/v1")
AUTH_HEADERS = ConfigLoader().get_auth_header()

# Initialize schema validator
validator = SchemaValidator()

# User schema for validation
USER_SCHEMA = {
    "type": "object",
    "required": ["id", "username", "email"],
    "properties": {
        "id": {"type": "string"},
        "username": {"type": "string"},
        "email": {"type": "string", "format": "email"},
        "first_name": {"type": "string"},
        "last_name": {"type": "string"},
        "role": {"type": "string"},
        "created_at": {"type": "string"}
    }
}

ERROR_SCHEMA = {
    "type": "object",
    "required": ["error"],
    "properties": {
        "error": {"type": "string"},
        "code": {"type": "integer"}
    }
}

def test_create_user_missing_email():
    """
    Test that creating a user with missing email returns a 400 error.
    This test validates that the API properly validates required fields
    and returns appropriate error messages.
    """
    # Prepare test data with missing email
    payload = {
        "username": "newuser",
        "first_name": "New",
        "last_name": "User",
        "password": "securepass123"
        # email is intentionally missing
    }
    
    # Send POST request to create user
    response = requests.post(f"{BASE_URL}/users", json=payload, headers=AUTH_HEADERS)
    
    # Assert status code is 400 Bad Request
    assert response.status_code == 400, f"Expected 400 Bad Request but got {response.status_code}"
    
    # Parse response body
    data = response.json()
    
    # Validate response schema
    validation_result = validator.validate_response_safe(data, ERROR_SCHEMA)
    assert validation_result["valid"], f"Schema validation failed: {validation_result['errors']}"
    
    # Assert error message mentions missing email
    assert "email" in data["error"].lower(), "Error should mention missing email field"
    
def test_get_users_pagination():
    """
    Test the users endpoint pagination functionality.
    This test validates that the pagination parameters are correctly applied
    and the response includes the expected pagination metadata.
    """
    # Define pagination parameters
    params = {
        "page": 1,
        "limit": 5
    }
    
    # Send GET request to users endpoint with pagination
    response = requests.get(f"{BASE_URL}/users", params=params, headers=AUTH_HEADERS)
    
    # Assert successful response
    assert response.status_code == 200, f"Expected 200 OK but got {response.status_code}"
    
    # Parse response
    data = response.json()
    
    # Basic structure validation
    assert "users" in data, "Response should contain 'users' array"
    assert "pagination" in data, "Response should contain pagination metadata"
    
    # Validate pagination parameters were applied
    pagination = data["pagination"]
    assert "page" in pagination, "Pagination metadata should include current page"
    assert pagination["page"] == params["page"], "Returned page should match requested page"
    
    assert "limit" in pagination, "Pagination metadata should include limit"
    assert pagination["limit"] == params["limit"], "Returned limit should match requested limit"
    
    # Validate user count matches limit (unless it's the last page)
    assert len(data["users"]) <= params["limit"], "Number of returned users should not exceed limit"

def test_update_user_partial():
    """
    Test partial update of user information (PATCH method).
    This test validates that the PATCH endpoint correctly updates
    only the provided fields while leaving others unchanged.
    """
    # First create a test user to update
    create_payload = {
        "username": "updateuser",
        "email": "update@example.com",
        "first_name": "Update",
        "last_name": "User",
        "password": "initialpass123"
    }
    
    create_response = requests.post(f"{BASE_URL}/users", json=create_payload, headers=AUTH_HEADERS)
    assert create_response.status_code == 201, "Failed to create test user for update test"
    
    # Get user ID from creation response
    user_id = create_response.json()["id"]
    
    # Prepare partial update payload
    update_payload = {
        "first_name": "Updated",
        "last_name": "Name"
    }
    
    # Send PATCH request
    update_response = requests.patch(
        f"{BASE_URL}/users/{user_id}",
        json=update_payload,
        headers=AUTH_HEADERS
    )
    
    # Assert successful response
    assert update_response.status_code == 200, f"Expected 200 OK but got {update_response.status_code}"
    
    # Parse response
    updated_user = update_response.json()
    
    # Validate schema
    validation_result = validator.validate_response_safe(updated_user, USER_SCHEMA)
    assert validation_result["valid"], f"Schema validation failed: {validation_result['errors']}"
    
    # Assert updated fields changed
    assert updated_user["first_name"] == update_payload["first_name"], "first_name should be updated"
    assert updated_user["last_name"] == update_payload["last_name"], "last_name should be updated"
    
    # Assert non-updated fields remained the same
    assert updated_user["email"] == create_payload["email"], "email should remain unchanged"
    assert updated_user["username"] == create_payload["username"], "username should remain unchanged"
    
    # Clean up - delete the test user
    requests.delete(f"{BASE_URL}/users/{user_id}", headers=AUTH_HEADERS)

def test_user_not_found():
    """
    Test that requesting a non-existent user returns a 404 error.
    """
    # Use a UUID that's unlikely to exist
    nonexistent_id = "11111111-1111-1111-1111-111111111111"
    
    # Send GET request for non-existent user
    response = requests.get(f"{BASE_URL}/users/{nonexistent_id}", headers=AUTH_HEADERS)
    
    # Assert 404 status code
    assert response.status_code == 404, f"Expected 404 Not Found but got {response.status_code}"
    
    # Parse response
    data = response.json()
    
    # Validate error schema
    validation_result = validator.validate_response_safe(data, ERROR_SCHEMA)
    assert validation_result["valid"], f"Schema validation failed: {validation_result['errors']}"
    
    # Check error message
    assert "not found" in data["error"].lower() or "doesn't exist" in data["error"].lower(), \
           "Error message should indicate user not found"
